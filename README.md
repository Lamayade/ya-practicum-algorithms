# Модуль Яндекса по алгоритмам

# Задача №10 - Проект Считалка
|                     |                                  |
|---------------------|----------------------------------|
| Ограничение времени | 1 секунда                        |
| Ограничение памяти  | 64.0 Мб                          |
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

Полёты на Марс с участием человека уже не за горами. Команда для полёта почти сформирована. Осталось одно свободное место и масса претендентов на него.

Для решения этой задачи создан проект С.Ч.И.Т.А.Л.К.А. — Стандартный Числовой Иррационально-Точный АЛгоритм Кастинга Астронавтов.

На практике алгоритм реализуется так:

Группа претендентов выстраивается в круг. Число претендентов обозначим через N, претенденты получают номера от 1 до N.

Претенденты получают лист бумаги, на котором написана считалка. Считалка состоит из определённого количества «ритмических частей», тактов. Число тактов обозначим через K.

Претендент под номером 1 произносит вслух считалку и, начиная с себя, на каждый такт указывает на каждого из претендентов. Тот, на ком считалка закончилась, выбывает из числа претендентов.

Участник, следующий за выбывшим, вновь начинает произносить считалку, начав с себя и указывая последовательно на оставшихся претендентов.

Отсев продолжается до тех пор, пока не останется только один претендент — именно он и войдёт в команду.

Посмотрим, как это сработает на примере считалки из 16 тактов для группы из 5 человек. Считалка разбита на такты символом |, а над каждым тактом стоит цифра от 1 до 5: она обозначает, на кого именно показывает ведущий в процессе счёта.

| 1       | 2         | 3         | 4    |
|---------|-----------|-----------|------|
| Десять, | девять,   | восемь,   | семь |
| 5       | 1         | 2         | 3    |
| В кора- | бле       | нет места | всем |
| 4       | 5         | 1         | 2    |
| Тот,    | кто плохо | кашу      | ел   |
| 3       | 4         | 5         | 1    |
| Нику    | да        | не поле   | тел! |

__Претендент под номером 1 выбывает.__
__Считать начинает претендент, следующий за выбывшим, его номер - 2, он начинает с себя:__

| 2       | 3         | 4         | 5    |
|---------|-----------|-----------|------|
| Десять, | девять,   | восемь,   | семь |
| 2       | 3         | 4         | 5    |
| В кора- | бле       | нет места | всем |
| 2       | 3         | 4         | 5    |
| Тот,    | кто плохо | кашу      | ел   |
| 2       | 3         | 4         | 5    |
| Нику    | да        | не поле   | тел! |

__Претендент под номером 5 выбывает.__
__Считать начинает претендент, следующий за выбывшим.__
__И так до последнего претендента.__

В считалке может быть от 1 до 500 ритмических шагов.

| Эни | бени   | аппер | боттом   |
|-----|--------|-------|----------|
| Не  | бывать | тебе  | пилотом! |

В кастинге может принимать участие от 1 до 500 претендентов.

Таким образом,

    N — любое положительное число от 1 до 500.
    K — любое положительное число от 1 до 500.

Задачу можно решить в цикле или рекурсивно — любой из этих способов подойдёт. Если же вы сможете выполнить задание и тем и другим способом, это будет высший пилотаж.
Формат ввода

Первая строка — целое число от 1 до 500, количество претендентов.

Вторая строка — целое число от 1 до 500, количество тактов в считалке.
Формат вывода

Целое число — номер победившего претендента.
Пример 1
| Ввод | Вывод |
|:----:|:-----:|
|  5 2 |   3   |

Пример 2
| Ввод | Вывод |
|:----:|:-----:|
|  5 1 |   5   |

Пример 3
| Ввод | Вывод |
|:----:|:-----:|
|  5 6 |   4   |

## Решение через цикл

Разберём данный в условии пример.
| 1       | 2         | 3         | 4    |
|---------|-----------|-----------|------|
| Десять, | девять,   | восемь,   | семь |
| 5       | 1         | 2         | 3    |
| В кора- | бле       | нет места | всем |
| 4       | 5         | 1         | 2    |
| Тот,    | кто плохо | кашу      | ел   |
| 3       | 4         | 5         | 1    |
| Нику    | да        | не поле   | тел! |

В нём 5 человек (people) и 16 тактов (beats).

Поскольку последний человек произнесёт 16 такт уже на выходе, то уйдет
человек через 15 тактов от начала.
Тогда можно взять остаток от деления суммы индекса человека в списке
и тактов без единицы на количество оставшихся человек - если человек
первый в списке, тогда получим выражение

(0 + 16 - 1) % 5 = 0

и первый из списка человек покинет группу

список_людей.pop(0)

В общем виде 

index = (index + beats - 1) % len(p_list)
p_list.pop(index)

Всё это загоняем в цикл, пока не останется один человек, и этого человека
выводим в качестве ответа.

## Решение через рекурсию

Решение через рекурсию подразумевает


# Задача № 12 - Сортировка слиянием блоков
|                     |                                  |
|---------------------|----------------------------------|
| Ограничение времени | 1 секунда                        |
| Ограничение памяти  | 64.0 Мб                          |
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |




Проснувшись однажды утром после беспокойного сна, Антон обнаружил, что изобрёл новый алгоритм сортировки.

Алгоритм предназначен для сортировки массивов длиной n, состоящих из уникальных чисел в диапазоне от 0 до n-1. Иными словами, массив должен содержать целые положительные числа от 0 до n-1, перемешанные как угодно. Например, если n = 8, то массив может быть таким:

__Массив длиной 8 элементов__
3 1 0 2 6 5 4 7  
__В массиве содержатся все целые числа в диапазоне от 0 до 7.__

Суть алгоритма: исходный массив разделяется на блоки так, чтобы каждый блок можно было отсортировать и при слиянии отсортированных блоков получился отсортированный массив. Менять блоки местами нельзя.

__Делим исходный массив на блоки, которые можно отсортировать:__

__Так нельзя: после сортировки блоков их не объединить в отсортированный массив.__
3 1 | 0 2 | 6 | 5 4 | 7 

__И так нельзя.__
3 | 1 0 2 | 6 5 4 7 

3 1 0 2 | 6 5 4 | 7  __А вот такое деление - в самый раз!__

__Сортируем блоки:__
0 1 2 3 | 4 5 6 | 7

__Объединяем блоки:__
0 1 2 3 4 5 6 7

__Получили отсортированный массив!__

Алгоритм сортировки состоит из трёх шагов:

    Разбить исходную последовательность на k блоков. Блоки могут иметь разные размеры. Первый блок обязательно должен содержать 0. Если длина первого блока — r элементов, то максимальным значением в первом блоке должно быть число r - 1. А следующий блок (если он вообще будет) должен содержать число r. Этот принцип должен соблюдаться и в последующих блоках.
    Отсортировать каждый из блоков.
    Объединить блоки в единый массив.

Такая сортировка выгодна в том случае, если разбить исходный массив на максимально возможное число блоков.

В этом задании вам предстоит реализовать только первый шаг: разбить массив на блоки и вернуть их количество.

Задание: написать программу, которая получает на вход массив и возвращает максимальное число блоков, на которое можно разбить этот массив так, чтобы сортировка отработала корректно.

Ещё один пример:

3 2 0 1 4 6 5

Минимальный размер первого блока — 4.

Если взять лишь первые два элемента, то отсортированная последовательность будет начинаться с двойки, а это неправильно. Если взять первые три элемента, то последовательность будет начинаться с нуля, но после него сразу же пойдёт двойка. Опять нехорошо.

А вот первые четыре элемента гарантируют, что первая часть результирующего массива будет корректной.

Четвёрку можно взять как отдельный блок из одного элемента.

Последние два элемента составят третий блок. Таким образом:

    первый блок: 3, 2, 0, 1;
    второй блок: 4;
    третий блок: 6, 5.

В этом примере ответ равен 3: чтобы сортировка блоками отработала корректно, полученный массив можно разделить максимум на три блока.
Формат ввода

В первой строке задано n — количество чисел для сортировки (n ≤ 1000). В следующей строке записаны числа от 0 до n - 1, которые надо разбить на блоки.
Формат вывода

Выведите максимальное число блоков, на которое можно разбить данные при использовании метода частичной сортировки.

## Решение через цикл
Пойдем по каждому элементу и сравним его значение __x__ и индекс __i__- если __n = x - i > 0__, то этот и следующие __n__ блоков - это один блок.
Если у нас __n = 0__, то блок собран, переходим к следующему.
Если значение __x__ равно последнему индексу __i_final__, то дальше идти нет смысла, выводим количество блоков и выходим из цикла.
